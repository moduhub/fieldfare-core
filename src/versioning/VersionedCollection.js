/**
 * Fieldfare: Backend framework for distributed networks
 *
 * Copyright 2021-2023 Adan Kvitschal
 * ISC LICENSE
 */

import { LocalHost } from '../env/LocalHost.js';
import { Chunk } from '../chunking/Chunk.js';
import { ChunkingUtils } from '../chunking/ChunkingUtils.js';
import { VersionStatement } from './VersionStatement.js';
import { VersionChain } from './VersionChain.js';
import { Utils } from '../basic/Utils.js';
import { logger } from '../basic/Log.js';
import { Collection } from '../structures/Collection.js';
import { Change } from './Change.js';
import { EventEmitter } from '../basic/EventEmitter.js';

/**
 * Represents a group of elements that can be altered
 * by a group of hosts in a collaborative manner. Any changes made to
 * the data must be commited by creating VersionStatements and sharing
 * them with all other hosts that use the same collection UUID,
 * that may accept or reject the changes based on a shared set of rules.
 */
export class VersionedCollection {

	constructor(uuid) {
		if(!uuid) {
			throw Error('uuid must be defined');
		}
		if(Utils.isUUID(uuid) === false) {
			throw Error('invalid uuid');
		}
		this.uuid = uuid;
		/**
		 * Name of the methods that can be used to alter the collection elements 'legally'.
		 * Any remote call to a method outside this set will be blocked.
		 * @type {Set<string, CollectionMethod>}
		 */
		this.allowedChanges = new Set([
			'createElement', 'deleteElement', 'merge'
		]);
		/**
		 * The version identifier is a string that identifies the current version of the collection
		 * using the chunk identifier assigned to the lastest version statement.
		 * @type {string}
		 */
		this.currentVersion = '';
		/**
		 * The version blacklist contains a set of version identifiers previously rejected by the
		 * local host. This is used to avoid re-checking out a version that was already rejected.
		 * @type {Set<string>}
		 */
		this.versionBlacklist = new Set();
		/**
		 * Events generated by this collection, such as version updates.
		 * @type {EventEmitter}
		 * @public
		 * @readonly
		 * @property
		 */
		this.events = new EventEmitter();
		/**
		 * The current action being executed by the collection.
		 */
		this.currentAction = null;
		/**
		 * A queue of actions to be executed by the collection.
		 * This is used to avoid concurrent changes.
		 */
		this.waiters = [];
	}

	async init() {
		/**
		 * A local copy of the collection, containing the version last checked out.
		 * @type {Collection}
		 */
		this.localCopy = await Collection.getLocalCollection(this.uuid);
		this.localCopy.publish();
		this.currentVersion = await this.localCopy.getState();
		Collection.track(this.uuid, async (remoteCollection) => {
			remoteCollection.getState().then(async (version) => {
				if(this.currentVersion !== version && this.versionBlacklist.has(version) === false) {
					try {
						await this.pull(version, remoteCollection.owner);
					} catch(e) {
						logger.debug('Pull failed due to error: '+e+'\n Version was blacklisted: ' + version);
						this.versionBlacklist.add(version);
					}
				}
			});
		});
	}

	async getVersionHistoryCache() {
		if(!this.versionHistoryCache) {
			this.versionHistoryCache = new Map();
		}
		const versionChain = new VersionChain(this.currentVersion, LocalHost.getID(), 50);
		let depth=0;
		for await(const {version, statement} of versionChain.versionsIterator()) {
			this.versionHistoryCache.set(version, depth++);
		}
		return this.versionHistoryCache;
	}

	startAction(...args) {
		if(this.currentAction) {
			return new Promise((resolve, reject) => {
				this.waiters.push({action: args, resolve, reject});
			});
		}
		this.currentAction = args;
	}

	completeAction() {
		const nextWaiter = this.waiters.shift();
		if(nextWaiter) {
			this.currentAction = nextWaiter.action;
			nextWaiter.resolve();
		} else {
			this.currentAction = null;
		}
	}

	async updateVersionStatement(statement) {
		const descriptor = {
			type: 'obj',
			obj: statement
		};
		if(await this.localCopy.hasElement('version')) {
			await this.localCopy.updateElement('version', descriptor);
		} else {
			await this.localCopy.createElement('version', descriptor);
		}
	}

	/**
	 * Apply a set of changes to the collection, bringing it to the head state of the chain.
	 * @async
	 * @param {VersionChain} chain - The chain of versions containing the changes to be applied.
	 * @param {boolean} [merge=false] - Whether to merge the changes with the current state of the collection.
	 * @throws {Error} If the state chain mismatch or if the method to execute is not defined.
	 * @returns {Promise<void>} A promise that resolves when the changes have been applied.
	 */
	async applyChain(chain, merge=false) {
		const statements = await chain.getStatementsArray();
		for await (const statement of statements) {
			const issuer = statement.source;
			const prevState = statement.data.prev;
			const currentState = await this.localCopy.getState();
			if(!merge
			&& prevState !== currentState) {
				throw Error('state chain mismatch');
			}
			const changesChunk = Chunk.fromIdentifier(statement.data.changes, chain.owner);
			const changes = await changesChunk.expand(1);
			logger.debug('[APPLY] Applying set of ' + changes.length + ' changes from ' + issuer);
			for (const descriptor of changes) {
				logger.debug('[APPLY] ' + descriptor.method);
				const change = await this.getChangeFromDescriptor(descriptor);
				change.setIssuer(issuer);
				await change.execute(merge);
			}
			await changesChunk.clone();
			await this.updateVersionStatement(statement);
		}
	}

	/**
	 * Returns a change object based on a descriptor object.
	 * @async
	 * @param {Object} descriptor - The descriptor object that represents the change to be applied.
	 * @param {string} descriptor.method - The name of the method to be called on the collection.
	 * @param {Array} descriptor.params - An array of parameters to be passed to the method.
	 * @param {string} [descriptor.issuer] - The ID of the user who initiated the change.
	 * @throws {Error} If the change is not allowed, the method is not defined, or the method does not return a Change object.
	 * @returns {Promise<Change>} A change object that represents the change to be applied.
	 */
	async getChangeFromDescriptor(descriptor) {
		if(this.allowedChanges.has(descriptor.method) === false) {
			throw Error('change is not allowed ' + descriptor.method);
		}
		const classMethod = this[descriptor.method].bind(this);
		if(!classMethod) {
			throw Error('change is not defined ' + descriptor.method);
		}
		const change = classMethod(...descriptor.params);
		if(change instanceof Change === false) {
			throw Error('class method ' + descriptor.method + ' does not return a Change object');
		}
		if(descriptor.issuer) {
			change.setIssuer(descriptor.issuer);
		}
		return change;
	}

	/**
	 * Force update to a given version, discarding any local changes.
	 * @param {string} version identifier of the version to update to.
	 * @param {string} hostIdentifier Host identifier from where the changes should be fetched.
	 */
	async checkout(version, hostIdentifier) {
		await this.localCopy.setState(version);
		this.currentVersion = version;
		this.events.emit('version', version);
	}

	/**
	 * Update to a given version, fetching changes from a given source host.
	 * @param {string} version 
	 * @param {HostIdentifier} source 
	 * @returns 
	 */
	async pull(version, source) {
		ChunkingUtils.validateIdentifier(version);
		if(this.versionBlacklist.has(version)) {
			throw Error('This version has been blacklisted');
		}
		const versionHistory = await this.getVersionHistoryCache();
		if(versionHistory.has(version)) {
			const depth = versionHistory.get(version);
			logger.debug('[PULL] Version ' + version + ' found in history at depth ' + depth + ', skipping');
			return;
		}
		await this.startAction('update', version);
		const initialState = await this.localCopy.startStaging();
		logger.debug('[PULL] Start staging, intial state: ' + initialState);
		try {
			logger.debug("[PULL] pull changes to version: " + version);
			const localChain = new VersionChain(this.currentVersion, LocalHost.getID(), 50);
			const remoteChain = new VersionChain(version, source, 50);
			const {
				version: commonVersion,
				depthA: localCommitsAhead,
				depthB: remoteCommitsAhead
			} = await VersionChain.findCommonVersion(localChain, remoteChain);
			logger.debug("[PULL] Common version is " + commonVersion);
			logger.debug("[PULL] Local collection is " + localCommitsAhead + " commits ahead");
			logger.debug("[PULL] Remote collection is " + remoteCommitsAhead + " commits ahead");
			//Limit to commonVersion, not including
			localChain.limit(commonVersion, false);
			remoteChain.limit(commonVersion, false);
			if(remoteCommitsAhead > 0
			&& remoteCommitsAhead >= localCommitsAhead) {
				if(localCommitsAhead > 0) {
					logger.debug('[PULL] Stashing local changes for merging later');
					await this.checkout(commonVersion);
				}
				await this.applyChain(remoteChain);
				const achievedState = await this.localCopy.getState();
				const expectedState = await remoteChain.head;
				logger.debug("[PULL] state after apply: " + achievedState);
				logger.debug("[PULL] expected state: " + expectedState);
				if(achievedState !== expectedState) {
					throw Error('final state mismatch');
				}
				if(localCommitsAhead > 0) {
					logger.debug('[PULL] Merging local changes from ' + localChain.base + " to " + localChain.head);
					await this.commit(this.merge(localChain.base, localChain.head), true);
					//TOTHINK: retract commit if changes were redundant?
				}
				logger.debug('[PULL] Wraping up staging');
				this.currentVersion = await this.localCopy.wrapUpStaging();
				this.events.emit('version', this.currentVersion);
				this.versionBlacklist.clear();
				logger.debug('[PULL]  Collection ' + this.uuid + ' updated successfully to version ' + this.currentVersion);
			} else {
				logger.debug("[PULL] Local chain is ahead of remote chain, nothing to do");
				//Local chain is ahead of remote, wait for remote to merge
				// Todo: notify him?
				await this.localCopy.abortStaging();
			}
		} catch (error) {
			const currentState = await this.localCopy.abortStaging();
			logger.debug('[PULL] Aborted staging, back to state ' + currentState);
			throw Error('Pull failed: ' + error, {cause: error});
		} finally {
			this.completeAction();
		}
	}

	/**
	 * Execute a set of changes and create a new version.
	 * @param {Change|Change[]} changes A single change or an array of changes to be executed.
	 */
	async commit(changes, now=false) {
		if(!now) {
			await this.startAction('commit', changes);
		}
		try {
			if(changes instanceof Array === false) {
				changes = [changes];
			}
			const prevState = await this.localCopy.getState();
			const changeDescriptors = [];
			for(const change of changes) {
				if(change instanceof Change === false) {
					throw Error('Invalid change');
				}
				change.setIssuer(LocalHost.getID());
				await change.execute();
				changeDescriptors.push(change.descriptor);
			}
			const versionStatement = new VersionStatement(LocalHost.getID(), {
				prev: prevState,
				ts: Date.now(),
				changes: await Chunk.fromObject(changeDescriptors)
			});
			await LocalHost.signMessage(versionStatement);
			await this.updateVersionStatement(versionStatement);
			this.currentVersion = await this.localCopy.getState();
			this.events.emit('version', this.currentVersion);
		} catch (error) {
			throw Error('Commit failed: ' + error, {cause: error});
		} finally {
			if(!now) {
				this.completeAction();
			}
		}
	}

	merge(base, head) {
		if(base instanceof Chunk) {
			base = base.id;
		}
		if(head instanceof Chunk) {
			head = head.id;
		}
		return new Change('merge', ...arguments)
		.setAction(async () => {
			const mergeChain = new VersionChain(head, LocalHost.getID(), 50);
			mergeChain.limit(base);
			await this.applyChain(mergeChain, true);
		})
	}

	createElement(name, descriptor) {
		return new Change('createElement', ...arguments)
			.setAction(async () => {
				await this.localCopy.createElement(name, descriptor);
			})
			.setMergePolicy(async () => {
				if(await this.hasElement(name)) {
					logger.log('info', 'createElement merge policy: element already exists, skipping');
					return false;
				}
				return true;
			})
	}

	deleteElement(name) {
		return new Change('deleteElement', ...arguments)
			.setAction(async () => {
				await this.localCopy.deleteElement(name);
			})
			.setMergePolicy(async () => {
				if(await this.hasElement(name) === false) {
					logger.log('info', 'deleteElement merge policy: element does not exist, skipping');
					return false;
				}
				return true;
			})
	}

};
